[
  {
    "objectID": "pages/210-exercise-PR.html",
    "href": "pages/210-exercise-PR.html",
    "title": ":: Exercise 1",
    "section": "",
    "text": "In this exercise we are going to use the a simple statistics library https://github.com/Bristol-Training/demo-stats-lib.Repository: https://github.com/Bristol-Training/demo-stats-lib\nForm groups of 3-6 people and assign roles within your group:\n\n1 person: Repository Owner (creates fork and manages PRs)\n1-2 people: Feature Developers A (add std_dev function)\n1-2 people: Feature Developers B (add NA handling)\n1-2 people: Code Formatters (apply Black formatting)\n\n\n\nPart 1: Repository Setup\nRepository Owner does these steps:\nStep 1: Fork the Repository\n\nGo to https://github.com/Bristol-Training/demo-stats-lib\nClick Fork (top-right)\nThis creates a copy under your GitHub account\n\nStep 2: Add Collaborators\n\nIn your forked repository, go to Settings → Collaborators\nClick Add people\nAdd each team member by their GitHub username\nTeam members will receive an email invitation they must accept\n\nStep 3: Everyone Clones the Fork\nAll team members (including owner):\n# Replace OWNER-USERNAME with the repository owner's username\ngit clone https://github.com/OWNER-USERNAME/demo-stats-lib.git\ncd demo-stats-lib\n\n\n\nPart 2: Parallel Development\n\nTask ATask BTask C\n\n\nObjective: Make statistics functions robust to missing values NA.\n\nTask Instructions\nStep 1: Create and switch to your feature branch\ngit checkout main\ngit pull origin main\ngit checkout -b feature/na-handling\nStep 2: Modify stats_lib.py\nAdd NA handling to existing functions. For example:\n# Filter out None values\nclean_data = [x for x in data if x is not None]\nAdd similar handling to all the functions (median, mode, etc.).\nStep 3: Update stats_demo.py to test with NA values\n# Add test cases with None values\ntest_data_with_na = [1, 2, None, 4, 5, None, 7]\nprint(f\"Mean (with NAs): {mean(test_data_with_na)}\")\nprint(f\"Variance (with NAs): {variance(test_data_with_na)}\")\nStep 4: Test your changes\npython stats_demo.py\nStep 5: Commit and push\ngit add stats_lib.py stats_demo.py\ngit commit -m \"Add NA handling to statistics functions\"\ngit push origin feature/na-handling\nStep 6: Create Pull Request\n\nGo to GitHub repository\nClick “Compare & pull request”\nTitle: \"Add NA handling to statistics functions\"\nDescription:\n## Changes\n- Added None value filtering to all statistics functions\n- Updated demo.py with NA test cases\n\n## Testing\n- Tested with datasets containing None values\n- All functions handle empty datasets appropriately\nClick “Create pull request” (don’t merge yet!)\n\n\n\n\n\nObjective: Add a new standard deviation function to the statistics library.\n\nTask Instructions\nStep 1: Create your feature branch\ngit checkout main\ngit pull origin main\ngit checkout -b feature/add-stdev\nStep 2: Add the std_dev function to stats_lib.py\nYou can use:\nimport math\n\nmath.sqrt(variance(data))\nStep 3: Update stats_demo.py to demonstrate std_dev\n# Demonstrate standard deviation\nprint(\"\\n--- Standard Deviation ---\")\nprint(f\"Standard deviation: {std_dev(data)}\")\nStep 4: Test your function\npython stats_demo.py\nYou should see the standard deviation calculated for the temperature data.\nStep 5: Commit and push\ngit add stats_lib.py demo.py\ngit commit -m \"Add std_dev function to calculate standard deviation\"\ngit push origin feature/add-stdev\nStep 6: Create Pull Request\n\nGo to GitHub repository\nClick “Compare & pull request”\nTitle: \"Add standard deviation function\"\nDescription:\n## Changes\n- Added `std_dev(data)` function to statistics.py\n- Function calculates standard deviation as sqrt(variance)\n- Updated stats_demo.py to demonstrate the new function\n\n## Testing\n- Manually tested with temperature datasets\n- Verified output matches expected results\nClick “Create pull request” (don’t merge yet!)\n\n\n\n\n\nObjective: Reformat the codebase using Black for consistent style.\n\nTask Instructions\nStep 1: Create your feature branch\ngit checkout main\ngit pull origin main\ngit checkout -b style/black-formatting\nStep 2: Apply Black formatting to your project\n# Format the entire project\nblack .\n\n# You should see output like:\n# reformatted stats_lib.py\n# reformatted stats_demo.py\n# 2 files reformatted, X files left unchanged\nStep 3: Review the changes\ngit diff\nNotice how Black has: - Adjusted line spacing - Reformatted string quotes - Fixed indentation - Wrapped long lines\nStep 4: Commit and push\ngit add .\ngit commit -m \"Apply Black formatting to entire codebase\"\ngit push origin style/black-formatting\nStep 5: Create Pull Request\n\nGo to GitHub repository\nClick “Compare & pull request”\nTitle: \"Apply Black code formatting\"\nDescription:\n## Changes\n- Applied Black formatter to all Python files\n- Ensures PEP 8 compliance\n- No functional changes, style only\n\n## Testing\n- Verified all existing tests still pass\n- Code functionality unchanged\nClick “Create pull request” (don’t merge yet!)\n\n\n\n\n\n\n\nPart 3: The Merge Challenge\nEveryone gathers together for this part.\nStep 1: Observe the Pull Requests\nRepository Owner should now have THREE open pull requests: - feature/na-handling (modifies existing functions + demo.py) - feature/add-stdev (adds new function + demo.py) - style/black-formatting (reformats all files)\nAll three modified stats_lib.py and demo.py!\nStep 2: Merge the First PR\nRepository Owner:\n\nChoose one PR (e.g., feature/na-handling)\nReview the changes on GitHub\nClick “Merge pull request”\nClick “Confirm merge”\nOptionally delete the branch\n\n✅ First PR merged successfully!\nStep 3: Attempt to Merge the Second PR\nNow try to merge the second PR (e.g., feature/add-stdev):\n❌ GitHub shows: “This branch has conflicts that must be resolved”\nWhy conflicts exist: - stats_lib.py: If Group A modified existing functions and Group B added a new function, there might be conflicts in imports or at the end of the file - stats_demo.py: Both groups added different test code to the same file",
    "crumbs": [
      ":: Exercise 1"
    ]
  },
  {
    "objectID": "pages/400-branch-protection.html",
    "href": "pages/400-branch-protection.html",
    "title": "Branch Protection",
    "section": "",
    "text": "Branch Protection Rules\nBranch protection rules enforce quality standards by restricting how code can be merged into important branches (like main).\n\nWhy Protect Branches?\nWithout protection:\n\nAnyone can push directly to main\nBroken code can reach production\nChanges might not be reviewed\nTests might be skipped\n\nWith protection:\n\nAll changes go through Pull Requests\nCode must be reviewed before merging\nTests must pass before merging\nMain branch always remains stable\n\n\n\nCommon Protection Rules\n\nRequire pull requests: No direct commits to main\nRequire reviews: At least N people must approve\nRequire status checks: Tests must pass\nEnforce linear history: No merge commits (rebase or squash only)\nRequire signed commits: Verify commit authenticity\nRestrict who can push: Only certain team members\n\n\n\nSetting Up Branch Protection\nTo set up branch protection on GitHub do:\nStep 1: Navigate to repository settings\n\nGo to your repository on GitHub\nClick “Settings” (you need admin access)\nClick “Branches” in the left sidebar\n\nStep 2: Add a protection rule\n\nClick “Add branch protection rule”\nIn “Branch name pattern”, enter main\n\nStep 3: Configure rules\nRecommended settings for teams:\n\nRequire a pull request before merging\n\nRequire approvals: 1 (or more for larger teams)\nDismiss stale pull request approvals when new commits are pushed\nRequire review from Code Owners (if you have a CODEOWNERS file)\n\nRequire status checks to pass before merging\n\nRequire branches to be up to date before merging\nSelect specific checks (e.g., “tests”, “lint”)\n\nRequire conversation resolution before merging\n\nEnsures all review comments are addressed\n\nRequire linear history\n\nKeeps history clean and readable\n\nDo not allow bypassing the above settings (recommended for production)\n\nStep 4: Save the rule\nClick “Create” or “Save changes”.\n\nTesting Branch Protection\nTry to push directly to main:\ngit checkout main\n# Make a change\ngit add .\ngit commit -m \"Test direct push\"\ngit push origin main\nYou’ll see an error:\nremote: error: GH006: Protected branch update failed for refs/heads/main.\nGood! Protection is working. You must now use Pull Requests.\n\n\n\n\nCode Quality Tools\nBranch protection becomes powerful when combined with automated checks.\n\n\n\n\n\n\nBenefits of Automated Checks\n\n\n\n\nCatch bugs before review: Reviewers focus on logic, not syntax\nEnforce standards: Everyone follows the same code style\nSave time: Automated checks run in minutes, not hours\nBuild confidence: Know that all tests pass before merging\nDocumentation: CI logs show exactly what was tested\n\n\n\n\nTypes of Automated Checks\n1. Continuous Integration (CI)\nAutomatically run tests on every Pull Request:\n# .github/workflows/test.yml\nname: Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: 3.9\n      - name: Install dependencies\n        run: pip install -r requirements.txt\n      - name: Run tests\n        run: pytest\n2. Code Linting\nCheck code style and potential errors:\n- name: Run flake8\n  run: flake8 .\n3. Code Coverage\nEnsure tests cover enough of the code:\n- name: Run tests with coverage\n  run: pytest --cov=. --cov-report=xml\n4. Security Scanning\nCheck for known vulnerabilities:\n- name: Security check\n  run: bandit -r .",
    "crumbs": [
      "Branch Protection"
    ]
  },
  {
    "objectID": "pages/999-contributors.html",
    "href": "pages/999-contributors.html",
    "title": "Contributors",
    "section": "",
    "text": "The course has been developed by the Jean Golding Institute.\nPart of this course is inspired by the originally written course by Christopher Woods and published at https://chryswoods.com/beginning_git.",
    "crumbs": [
      "Contributors"
    ]
  },
  {
    "objectID": "pages/300-conflicts.html",
    "href": "pages/300-conflicts.html",
    "title": "Handling Merge Conflicts",
    "section": "",
    "text": "A merge conflict occurs when Git can’t automatically combine changes because two people have edited the same part of a file in different ways.\nConflicts happen when:\n\nYou and a colleague both modify the same line of code\nOne person edits a line while another deletes it\nChanges are made in overlapping sections of a file\n\nImportantly, conflicts do not occur when:\n\nChanges are in different files\nChanges are in different parts of the same file\nOne person’s changes come entirely before or after another’s\n\n\nExample Scenario\nYou and your colleague both create branches from main:\nmain: A -- B -- C\n             \\\n              \\-- D (your branch: change line 5)\n               \\\n                \\-- E (colleague's branch: change line 5)\nYour colleague merges first. When you try to merge, Git sees:\n\nMain now has E (colleague’s version of line 5)\nYour branch has D (your version of line 5)\nGit doesn’t know which to keep, so it asks you to decide\n\n\n\nWhat Conflicts Look Like\nWhen you encounter a conflict, Git marks the conflicting section in your file:\ndef calculate_total(items):\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n    # Current branch version\n    total = sum(item.price * 1.2 for item in items)  # With 20% tax\n=======\n    # Incoming branch version\n    total = sum(item.price * 1.15 for item in items)  # With 15% tax\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature/update-tax-calculation\n    return total\nThe markers mean:\n\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD: Start of your current branch’s version\n=======: Divider between the two versions\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch-name: End of the incoming branch’s version\n\n\n\nResolving Conflicts\nWhen you encounter a merge conflict, follow these steps to resolve it:\n\nStep 1: Identify the Conflicts\nAfter attempting a merge, Git will tell you which files have conflicts:\n$ git merge feature/update-tax-calculation\nAuto-merging calculator.py\nCONFLICT (content): Merge conflict in calculator.py\nAutomatic merge failed; fix conflicts and then commit the result.\nYou can see all conflicted files with:\n$ git status\nFiles with conflicts will be listed under “Unmerged paths.”\n\n\nStep 2: Open and Edit the Conflicted Files\nOpen each conflicted file in your editor. You’ll see the conflict markers as shown earlier. Your job is to:\n\nDecide which version to keep (yours, theirs, or a combination)\nRemove the conflict markers (&lt;&lt;&lt;&lt;&lt;&lt;&lt;, =======, &gt;&gt;&gt;&gt;&gt;&gt;&gt;)\nKeep only the final code you want\n\nOption A: Keep your version\ndef calculate_total(items):\n    total = sum(item.price * 1.2 for item in items)  # With 20% tax\n    return total\nOption B: Keep their version\ndef calculate_total(items):\n    total = sum(item.price * 1.15 for item in items)  # With 15% tax\n    return total\nOption C: Combine both (if it makes sense)\ndef calculate_total(items, tax_rate=0.15):\n    total = sum(item.price * (1 + tax_rate) for item in items)\n    return total\n\n\nStep 3: Mark as Resolved\nAfter editing the file and removing all conflict markers, stage it:\n$ git add calculator.py\nThis tells Git that you’ve resolved the conflict in that file.\n\n\nStep 4: Complete the Merge\nOnce all conflicts are resolved and staged, complete the merge with:\n$ git commit\nGit will open your editor with a pre-filled commit message. You can modify it to explain how you resolved the conflicts, then save and close.\n\n\nBest Practices for Conflict Resolution\n\nTest your code after resolving conflicts to ensure it works correctly\nCommunicate with your team if you’re unsure which version to keep\nReview the full context by looking at both branches, not just the conflicted lines\nUse git diff to see what changed in each branch before making decisions\nDon’t rush — conflicts often reveal important differences in approach\n\n\n\nAborting a Merge\nIf you want to cancel the merge and start over:\n$ git merge --abort\nThis returns your repository to the state before you attempted the merge.\n\nThis section provides practical, step-by-step guidance while maintaining the instructional tone of your existing content. Would you like me to adjust anything or add more detail to any particular step?\n\n\n3.2 Exercise 2: Creating and Resolving Conflicts (15 minutes)\nLet’s intentionally create a conflict to practice resolving it.\n\nPart A: Creating a Conflict\nSetup: Work with a partner, or simulate two developers by using two different branches yourself.\nPerson A (or Branch 1):\ngit checkout main\ngit pull origin main\ngit checkout -b feature/update-multiply-docstring\n\n# Edit calc_lib.py - update the multiply function's docstring\nChange the multiply function docstring to:\ndef multiply(a, b):\n    \"\"\"\n    Multiply two numbers together.\n    \n    Args:\n        a (float): First multiplicand\n        b (float): Second multiplicand\n    \n    Returns:\n        float: The product of a and b\n    \"\"\"\n    return a * b\ngit add calc_lib.py\ngit commit -m \"Improve multiply function documentation\"\ngit push origin feature/update-multiply-docstring\nCreate a Pull Request and merge it.\nPerson B (or Branch 2):\ngit checkout main\ngit pull origin main\ngit checkout -b feature/enhance-multiply-docstring\n\n# Edit calc_lib.py - update the same multiply function's docstring differently\nChange the multiply function docstring to:\ndef multiply(a, b):\n    \"\"\"\n    Calculate the product of two numbers.\n    \n    Parameters:\n        a (float): The first number\n        b (float): The second number\n    \n    Returns:\n        float: a multiplied by b\n    \n    Example:\n        &gt;&gt;&gt; multiply(4, 5)\n        20\n    \"\"\"\n    return a * b\ngit add calc_lib.py\ngit commit -m \"Add example to multiply function documentation\"\ngit push origin feature/enhance-multiply-docstring\nCreate a Pull Request. GitHub will indicate there’s a conflict!\n\n\nPart B: Resolving the Conflict\nWhen GitHub shows a conflict, you have two options:\n\nResolve on GitHub (web interface): Good for simple conflicts\nResolve locally (command line): Better for complex conflicts\n\nLet’s resolve it locally:\n# Make sure you're on your feature branch\ngit checkout feature/enhance-multiply-docstring\n\n# Pull the latest main which now contains the merged changes\ngit pull origin main\nGit will report a conflict:\nAuto-merging calc_lib.py\nCONFLICT (content): Merge conflict in calc_lib.py\nAutomatic merge failed; fix conflicts and then commit the result.\nStep 1: Check which files have conflicts\ngit status\nYou’ll see:\nUnmerged paths:\n  both modified:   calc_lib.py\nStep 2: Open the conflicting file\nOpen calc_lib.py in your editor. You’ll see:\ndef multiply(a, b):\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n    \"\"\"\n    Calculate the product of two numbers.\n    \n    Parameters:\n        a (float): The first number\n        b (float): The second number\n    \n    Returns:\n        float: a multiplied by b\n    \n    Example:\n        &gt;&gt;&gt; multiply(4, 5)\n        20\n    \"\"\"\n=======\n    \"\"\"\n    Multiply two numbers together.\n    \n    Args:\n        a (float): First multiplicand\n        b (float): Second multiplicand\n    \n    Returns:\n        float: The product of a and b\n    \"\"\"\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; main\n    return a * b\nStep 3: Decide what to keep\nYou have three options: 1. Keep your version (HEAD) 2. Keep their version (main) 3. Combine both (usually best!)\nLet’s combine the best of both:\ndef multiply(a, b):\n    \"\"\"\n    Multiply two numbers together.\n    \n    Args:\n        a (float): First multiplicand\n        b (float): Second multiplicand\n    \n    Returns:\n        float: The product of a and b\n    \n    Example:\n        &gt;&gt;&gt; multiply(4, 5)\n        20\n    \"\"\"\n    return a * b\nRemove all conflict markers (&lt;&lt;&lt;&lt;&lt;&lt;&lt;, =======, &gt;&gt;&gt;&gt;&gt;&gt;&gt;).\nStep 4: Mark the conflict as resolved\ngit add calc_lib.py\nStep 5: Complete the merge\ngit commit -m \"Merge main and resolve docstring conflict\n\nCombined both documentation improvements:\n- Kept clear docstring from main\n- Added example from feature branch\"\nStep 6: Push the resolved changes\ngit push origin feature/enhance-multiply-docstring\nYour Pull Request now shows no conflicts and can be merged!\n\n\n\n3.3 Strategies to Minimise Conflicts (5 minutes)\nWhile conflicts are normal, you can reduce their frequency:\n\n1. Communicate with Your Team\n\nDiscuss who’s working on what\nAvoid multiple people editing the same files simultaneously\nUse project management tools to track work\n\n\n\n2. Keep Pull Requests Small\n\nSmaller changes = fewer conflicts\nMerge frequently rather than letting branches grow stale\n\n\n\n3. Pull from Main Regularly\n# While on your feature branch\ngit pull origin main\nThis keeps your branch up to date and surfaces conflicts early when they’re easier to resolve.\n\n\n4. Structure Code to Reduce Overlap\n\nModular code with clear boundaries\nEach function/class in its own file when reasonable\nAvoid giant files that everyone needs to edit\n\n\n\n5. Use Feature Flags\nFor long-running features, merge incomplete work behind a feature flag:\nENABLE_NEW_FEATURE = False\n\nif ENABLE_NEW_FEATURE:\n    # New code path\nelse:\n    # Existing code path\nThis allows you to merge regularly without activating incomplete features.",
    "crumbs": [
      "Handling Merge Conflicts"
    ]
  },
  {
    "objectID": "pages/610-exercise-ghactions.html",
    "href": "pages/610-exercise-ghactions.html",
    "title": ":: Exercise 3",
    "section": "",
    "text": "In this exercise we’ll add automated testing to the statistics library using GitHub Actions. This ensures all future pull requests are automatically tested before merging.\n\nPart 1: Understanding the Current Tests\nStep 1: Explore the existing test file\nOpen test_stats_lib.py in your repository. You’ll see pytest tests for the statistics functions.\nStep 2: Run tests locally\n# Run the tests\npytest test_stats_lib.py\n\n# Run with coverage report\npytest --cov=stats_lib test_stats_lib.py\nYou should see all tests pass with the merged code from the previous exercises.\n\n\n\nPart 2: Create a GitHub Actions Workflow\nThe Repository Owner leads this part, but everyone should follow along in their own clone.\nStep 1: Create the workflow directory structure\nmkdir -p .github/workflows\nStep 2: Create the workflow file\nCreate the workflow file .github/workflows/pytest.yml. You can use the workflow in https://github.com/Bristol-Training/demo-calc-lib as a template.\nStep 3: Ensure requirements.txt exists\nIf it doesn’t exist, create it. Since this is a simple library, the file might be minimal or empty, but it should exist for the workflow.\nStep 4: Commit and push\ngit add .github/workflows/pytest.yml\ngit add requirements.txt  # if you created it\ngit commit -m \"Add GitHub Actions workflow for automated testing\"\ngit push origin main\nStep 5: Verify the workflow runs\n\nGo to your GitHub repository\nClick the Actions tab\nYou should see your workflow running (yellow circle) or completed (green checkmark)\nClick on the workflow run to see detailed logs\n\n✅ Automated testing is now active!\n\n\n\nPart 3: Test the Workflow with a Pull Request\nNow let’s see GitHub Actions in action by creating a pull request with failing tests.\nStep 1: Create a buggy branch\ngit checkout main\ngit pull origin main\ngit checkout -b feature/buggy-median\nStep 2: Introduce a bug in stats_lib.py\nFind the median function and change it to:\ndef median(data):\n    \"\"\"Calculate median (with an intentional bug).\"\"\"\n    clean_data = [x for x in data if x is not None]\n    \n    if not clean_data:\n        raise ValueError(\"No valid data points\")\n    \n    sorted_data = sorted(clean_data)\n    n = len(sorted_data)\n    \n    # BUG: Wrong calculation!\n    return sorted_data[0]  # Always returns the first element\nStep 3: Commit and push (without testing locally!)\ngit add stats_lib.py\ngit commit -m \"Update median calculation\"\ngit push origin feature/buggy-median\nStep 4: Create Pull Request\n\nCreate the pull request on GitHub\nWatch the checks run\nNotice the red X ❌\nClick “Details” to see which test failed\nThe PR shows “Some checks were not successful”\n\nStep 5: Fix the bug\n# Fix the median function back to correct implementation\ngit add stats_lib.py\ngit commit -m \"Fix median calculation\"\ngit push origin feature/buggy-median\nStep 6: Create Pull Request\n\nGo to GitHub and create a pull request\nNotice the yellow circle appears next to your PR - checks are running!\nWait for it to turn into a green checkmark ✅\nThe PR shows “All checks have passed”\n\nRepository Owner can merge this PR with confidence!",
    "crumbs": [
      ":: Exercise 3"
    ]
  },
  {
    "objectID": "pages/310-exercise-merge.html",
    "href": "pages/310-exercise-merge.html",
    "title": ":: Exercise 2",
    "section": "",
    "text": "Resolve the conflicts generated in the previous exercise when we created three pull requests: - feature/na-handling (modifies existing functions + stats_demo.py) - feature/add-stdev (adds new function + stats_demo.py) - style/black-formatting (reformats all files)\n\nStep 1. Attempt to Merge the Second PR\nNow try to merge the second PR (e.g., feature/add-stdev):\n❌ GitHub shows: “This branch has conflicts that must be resolved”\nWhy conflicts exist: - stats_lib.py: If Group A modified existing functions and Group B added a new function, there might be conflicts in imports or at the end of the file - stats_demo.py: Both groups added different test code to the same file\n\n\nStep 2. Resolve Conflicts for Second PR\nThe person who created feature/add-stdev should:\nStep 1: Update your local repository\ngit checkout main\ngit pull origin main  # Get the merged changes from feature/na-handling\nStep 2: Merge main into your feature branch\ngit checkout feature/add-stdev\ngit merge main\nOutput might show:\nAuto-merging stats_lib.py\nAuto-merging stats_demo.py\nCONFLICT (content): Merge conflict in stats_demo.py\nAutomatic merge failed; fix conflicts and then commit the result.\nStep 3: Resolve stats_demo.py conflicts\nOpen stats_demo.py and look for conflict markers:\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n# Your std_dev demo code\nprint(\"\\n--- Standard Deviation ---\")\nprint(f\"Standard deviation: {std_dev(data)}\")\n=======\n# The NA handling demo code from main\ntest_data_with_na = [1, 2, None, 4, 5, None, 7]\nprint(f\"Mean (with NAs): {mean(test_data_with_na)}\")\nprint(f\"Variance (with NAs): {variance(test_data_with_na)}\")\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; main\nResolution: Keep BOTH sets of changes:\n# NA handling demo\ntest_data_with_na = [1, 2, None, 4, 5, None, 7]\nprint(f\"Mean (with NAs): {mean(test_data_with_na)}\")\nprint(f\"Variance (with NAs): {variance(test_data_with_na)}\")\n\n# Standard deviation demo\nprint(\"\\n--- Standard Deviation ---\")\nprint(f\"Standard deviation: {std_dev(data)}\")\nprint(f\"This measures spread from the mean\")\nStep 4: Check if stats_lib.py has conflicts\nIf the std_dev function uses variance (which now has NA handling), you might need to update it or ensure it works correctly with the new NA-handling code.\nStep 5: Test everything works\npython stats_demo.py\nStep 6: Commit the resolution\ngit add stats_demo.py stats_lib.py\ngit commit -m \"Resolve merge conflict: combine NA handling with std_dev function\"\ngit push origin feature/add-stdev\nStep 7: Merge the PR on GitHub\nThe PR should now show no conflicts. Repository Owner can merge it!\n✅ Second PR merged successfully!\n\n\nStep 3: Resolve Conflicts for Third PR (Black Formatting)\nNow the final PR (style/black-formatting) will definitely have conflicts because it reformatted code that has since been modified.\nThe person who created style/black-formatting should:\nStep 1: Update and merge\ngit checkout main\ngit pull origin main\ngit checkout style/black-formatting\ngit merge main\nOutput:\nAuto-merging stats_lib.py\nCONFLICT (content): Merge conflict in stats_lib.py\nAuto-merging stats_demo.py\nCONFLICT (content): Merge conflict in stats_demo.py\nAutomatic merge failed; fix conflicts and then commit the result.\nStep 2: Resolve conflicts in stats_lib.py\nYou’ll see conflicts where Black’s formatting meets the new code:\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n# Black-formatted original code\ndef mean(data):\n    return sum(data) / len(data)\n=======\n# New NA-handling version with different formatting\ndef mean(data):\n    \"\"\"Calculate mean, ignoring None values.\"\"\"\n    clean_data = [x for x in data if x is not None]\n    \n    if not clean_data:\n        raise ValueError(\"No valid data points\")\n    \n    return sum(clean_data) / len(clean_data)\n\ndef std_dev(data):\n    \"\"\"Calculate standard deviation...\"\"\"\n    return math.sqrt(variance(data))\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; main\nResolution strategy: Keep ALL the new functionality from main (NA handling + std_dev), then re-apply Black:\n\nAccept all changes from main (the NA handling and std_dev function)\nRemove conflict markers\nRun Black again to format everything\n\nStep 3: Accept main’s version and re-format\n# For each conflicted file, accept their changes\ngit checkout --theirs stats_lib.py stats_demo.py\n\n# Re-apply Black to format the new code\nblack .\nStep 4: Verify everything still works\npython stats_demo.py\nYou should see output for: - Original statistics - NA handling tests - Standard deviation calculation\nStep 5: Commit the resolution\ngit add .\ngit commit -m \"Resolve merge conflicts: apply Black formatting to updated codebase\"\ngit push origin style/black-formatting\nStep 6: Merge the final PR\nRepository Owner can now merge the last PR!\n✅ All three PRs successfully merged!",
    "crumbs": [
      ":: Exercise 2"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "The report_final_v3_FINAL.docx Problem\nHave you ever experienced a situation like this?\n\nYou’re writing a report with colleagues. You start with report.docx and email it to your supervisor for comments. They return report_with_corrections.docx. Meanwhile, you’ve made more changes, creating report_v2.docx, and emailed it to a collaborator to add their section. You try to incorporate the supervisor’s suggestions from report_with_corrections.docx into report_v2.docx, creating report_v3.docx. Then your supervisor sends report_with_corrections_more.docx and your collaborator returns report_v2_my_additions.docx.\n\nThis scenario illustrates several common problems with ad-hoc collaboration:\n\nNo single source of truth: Which version is the “correct” one?\nLost work: Changes made in one version may not make it into another\nConfusion: Who made which changes and when?\nMerge nightmares: Manually combining changes is error-prone and time-consuming\nVersioning chaos: Filenames become increasingly absurd\n\n\n\nGit as a Single Source of Truth\nGit and GitHub solve these problems by providing a single source of truth — a central repository that contains the authoritative version of your project. All collaborators work on their own local copies, make changes, and synchronise those changes through the central repository.\nThis approach provides:\n\nClear history: Every change is tracked with who made it and why\nNo lost work: All changes are preserved in the version history\nSafe experimentation: Work can happen in parallel without interfering\nAutomatic merging: Git handles most merge scenarios automatically\nConflict resolution tools: When conflicts occur, Git helps you resolve them\n\n\n\nIntended learning outcomes\nBy the end of this course, you will:\n\nApply GitHub Flow for team collaboration\nCreate and manage feature branches effectively\nWrite clear, focused Pull Requests\nConduct constructive code reviews\nResolve merge conflicts confidently\nImplement branch protection rules for code quality\n\n\n\nPrerequisites\nBefore starting this session, you should be comfortable with:\n\nBasic Git commands (git add, git commit, git push, git pull)\nCreating and using GitHub repositories, including forks\nUnderstanding what commits and repositories are\nBasic command line navigation\nPython programming",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "pages/600-gh-actions.html",
    "href": "pages/600-gh-actions.html",
    "title": "GitHub Actions",
    "section": "",
    "text": "GitHub Actions is a powerful automation tool that enables Continuous Integration (CI) and Continuous Deployment (CD) directly within your GitHub repository. With GitHub Actions, you can define workflows that automatically build, test, and deploy your code whenever changes are made. This ensures that your code is always in a deployable state and helps catch issues early in the development process.\nBy leveraging GitHub Actions, teams can streamline their development workflows, reduce manual intervention, and improve collaboration. Whether you’re running tests on every push, deploying to production after successful builds, or automating other tasks, GitHub Actions provides a flexible and scalable solution for modern software development practices.",
    "crumbs": [
      "GitHub Actions"
    ]
  },
  {
    "objectID": "pages/600-gh-actions.html#setting-up-github-actions",
    "href": "pages/600-gh-actions.html#setting-up-github-actions",
    "title": "GitHub Actions",
    "section": "Setting Up GitHub Actions",
    "text": "Setting Up GitHub Actions\n\nStep 1: Create the Workflow Directory\nIf it doesn’t exist already, create the following directory structure in your repository:\nyour-repo/\n├── .github/\n│   └── workflows/\n│       └── tests.yml\n\n\nStep 2: Add the Workflow File\nCreate a file called test-calc-lib.yml in .github/workflows/ with this content:\nname: Run Python Tests\n\non:\n  push:\n    branches: [ main, master ]\n  pull_request:\n    branches: [ main, master ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    strategy:\n      matrix:\n        python-version: ['3.8', '3.9', '3.10', '3.11']\n    \n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n    \n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v5\n      with:\n        python-version: ${{ matrix.python-version }}\n    \n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install pytest pytest-cov\n    \n    - name: Run tests with pytest\n      run: |\n        pytest test_calc_lib.py -v --cov=calc_lib --cov-report=term-missing\n    \n    - name: Test demo script runs\n      run: |\n        python calc_demo.py\n\n\nStep 3: Commit and Push\ngit add .github/workflows/tests.yml\ngit commit -m \"ci: add GitHub Actions workflow for automated testing\"\ngit push origin main\n\n\nStep 4: View Your Workflow\n\nGo to your repository on GitHub\nClick the “Actions” tab at the top\nYou should see your workflow running! When you click on a workflow run, you’ll see:\n\n✅ Run Tests\n  └─ test\n     ├─ Checkout code (✓)\n     ├─ Set up Python (✓)\n     ├─ Install dependencies (✓)\n     └─ Run tests (✓ or ✗)",
    "crumbs": [
      "GitHub Actions"
    ]
  },
  {
    "objectID": "pages/600-gh-actions.html#understanding-the-workflow",
    "href": "pages/600-gh-actions.html#understanding-the-workflow",
    "title": "GitHub Actions",
    "section": "Understanding the Workflow",
    "text": "Understanding the Workflow\n\nTriggers (on:)\non:\n  push:\n    branches: [ main, master ]\n  pull_request:\n    branches: [ main, master ]\n\nTests run when you push to the main branch\nTests run when someone creates a pull request to main\n\n\n\nJob Configuration (jobs:)\njobs:\n  test:\n    runs-on: ubuntu-latest\n\nCreates a job called “test”\nRuns on the latest Ubuntu virtual machine\n\n\n\nSteps (steps:)\nEach step is a task that runs in sequence:\n\nCheckout code - Downloads your repository code\nSet up Python - Installs Python (one or multiple versions)\nInstall dependencies - Installs packages from requirements.txt\nRun tests - Executes pytest\n\n\n\nBranch Protection (optional)\nRequire tests to pass before merging:\n\nGo to Settings → Branches\nAdd branch protection rule for main\nCheck “Require status checks to pass before merging”\nSelect your test workflow\nSave changes\n\nNow PRs can’t be merged if tests fail!",
    "crumbs": [
      "GitHub Actions"
    ]
  },
  {
    "objectID": "pages/100-gh-flow.html",
    "href": "pages/100-gh-flow.html",
    "title": "GitHub Flow",
    "section": "",
    "text": "The GitHub Flow is an industry-standard workflow for continuous delivery and collaboration. It’s lightweight, branch-based, and supports teams of any size working on projects of any complexity.\n\n\n\n\n\n\nThe Six Key Steps\n\n\n\n\nFork and clone the repository URL: Fork the repository on GitHub and clone your fork locally so you can start working on changes\nPull latest from main branch: Always start with the most recent code\nCreate a feature branch: Make a new branch for your work\nMake commits on your branch: Save your changes regularly\nPush branch and open Pull Request: Share your work and request feedback\nDiscuss and review code: Collaborate with teammates on improvements\nMerge to main and delete branch: Integrate approved changes and clean up\n\n\n\n\nStep 0: Fork and clone the repository URL\nNavigate to the repository on GitHub and click “Fork” to create your own copy. On your forked repository page in GitHub, click the green “Code” button and copy the HTTPS URL (it should look like https://github.com/YOUR-USERNAME/demo-calc-lib.git).\ngit clone https://github.com/YOUR-USERNAME/demo-calc-lib.git\ncd demo-calc-lib\n\n\nStep 1: Pull Latest from Main Branch\nBefore starting new work, ensure you have the latest version of the main branch:\ngit checkout main\ngit pull origin main\nThis ensures you’re building on the most recent stable version, reducing the chance of conflicts later.\n\n\nStep 2: Create a Feature Branch\nCreate a new branch for your feature or fix:\ngit checkout -b feature/add-user-authentication\nBranch naming conventions help teams stay organised:\n\nfeature/ — for new features (e.g., feature/add-login-page)\nfix/ or bugfix/ — for bug fixes (e.g., fix/correct-calculation-error)\ndocs/ — for documentation updates (e.g., docs/update-readme)\nrefactor/ — for code improvements (e.g., refactor/simplify-database-queries)\n\nUse descriptive names that explain what the branch does. Avoid vague names like my-branch or updates.\n\n\nStep 3: Make Commits on Your Branch\nWork on your changes and commit regularly:\n# Make changes to files\ngit add .\ngit commit -m \"Add login form component\"\n\n# Make more changes\ngit add .\ngit commit -m \"Add authentication validation logic\"\nGood commit practices:\n\nCommit small, logical chunks of work\nWrite clear, descriptive commit messages\nUse present tense (“Add feature” not “Added feature”)\nExplain what and why, not how\n\n\n\nStep 4: Push Branch and Open Pull Request\nPush your branch to GitHub:\ngit push origin feature/add-user-authentication\nThen, on GitHub:\n\nNavigate to your repository\nClick “Compare & pull request” (appears after pushing)\nWrite a clear title and description\nRequest reviewers\nClick “Create pull request”\n\n\n\nStep 5: Discuss and Review Code\nThis is where collaboration happens:\n\nReviewers examine the code, suggest improvements, and ask questions\nAuthor responds to comments and makes requested changes\nDiscussion happens directly on the Pull Request\n\nTo make changes based on feedback:\n# Still on your feature branch\n# Make the requested changes\ngit add .\ngit commit -m \"Address review comments: improve error handling\"\ngit push origin feature/add-user-authentication\nThe Pull Request automatically updates with your new commits.\n\n\nStep 6: Merge to Main and Delete Branch\nOnce approved, merge the Pull Request via GitHub’s interface:\n\nClick “Merge pull request”\nConfirm the merge\nDelete the branch (GitHub prompts you to do this)\n\nThen, locally:\ngit checkout main\ngit pull origin main\ngit branch -d feature/add-user-authentication\n\n\n\n\n\n\nWhy This Matters\n\n\n\nGitHub Flow enables teams to:\n\nShip code safely and frequently: Small, reviewed changes are less risky\nWork in parallel: Multiple features can be developed simultaneously\nMaintain code quality: Code review catches bugs and improves design\nPreserve project stability: The main branch always contains working code\nDocument decisions: Pull Request discussions provide context for future developers",
    "crumbs": [
      "GitHub Flow"
    ]
  },
  {
    "objectID": "pages/200-pull-requests.html",
    "href": "pages/200-pull-requests.html",
    "title": "Pull Requests & Review",
    "section": "",
    "text": "Writing Effective Pull Requests\nA Pull Request (PR) is more than just code — it’s communication with your team. A good PR makes reviewing easier and faster.\nFollow these tips to write effective pull requests:\n1. Clear, Descriptive Title\n❌ Bad: “Updates”\n❌ Bad: “Fix bug”\n✅ Good: “Add power function for exponent calculations”\n✅ Good: “Fix division by zero error in calculator”\n2. Comprehensive Description\nUse a template:\n## Purpose\nBrief explanation of why this change is needed.\n\n## Changes\n- Bullet list of what was changed\n- Include files modified and what was done\n\n## Testing\nHow you verified the changes work correctly.\n\n## Screenshots (if applicable)\nVisual changes should include before/after images.\n\n## Related Issues\nCloses #123\nRelates to #456\n3. Small, Focused Changes\n\nOne feature or fix per Pull Request\nAim for under 400 lines of changes\nIf it’s getting large, consider breaking it into multiple PRs\n\n4. Self-Review First\nBefore requesting review:\n\nReview your own code on GitHub\nCheck for debugging code or comments to remove\nVerify tests pass\nEnsure code follows project style guidelines\n\n\n\n\n\n\n\nA Good Pull Request\n\n\n\n\nTitle\nAdd modulo operation to calculator library\n\n\nPurpose\nUsers need to calculate remainders in division operations. This adds modulo functionality to support use cases like determining odd/even numbers or circular buffer indexing.\n\n\nChanges\n\nAdded modulo(a, b) function to calc_lib.py\nAdded unit tests in test_calc.py\nUpdated README.md with usage examples\nUpdated calc_demo.py to demonstrate modulo operation\n\n\n\nTesting\n\nAll existing tests pass\nNew tests cover positive numbers, negative numbers, and zero divisor\nManually verified examples in README\n\n\n\nNotes\nRaises ValueError when divisor is zero, consistent with existing divide() function behaviour.\n\n\n\n\n\nCode Review Best Practices\nCode review is a skill that requires practice. Good reviews improve code quality while maintaining team morale.\n\nFor Reviewers: How to Review Constructively\n1. Be Kind and Respectful\nFrame feedback constructively:\n❌ “This code is terrible”\n✅ “This could be more efficient using a list comprehension”\n2. Distinguish Between Issues and Suggestions\nClarify what’s required vs optional:\n\nMust fix: “This will cause a bug with negative input”\nShould consider: “Consider extracting this into a separate function”\nNice to have: “Descriptive variable names improve readability”\n\n3. Provide Specific, Actionable Feedback\n❌ Vague: “This function needs work”\n✅ Specific: “Add a check for None values at line 42.”\n4. Praise Good Work\nAcknowledge positives:\n\n“Nice solution to this edge case!”\n“Great test coverage!”\n\n5. Review the Right Things\nFocus on:\n\nCorrectness: Does it work?\nDesign: Is it maintainable?\nTests: Are they adequate?\nDocumentation: Are changes documented?\n\nAvoid:\n\nPersonal style preferences (use automated formatters instead)\nTrivial spacing issues (use linters instead)\n\n\n\nFor Authors: Receiving Feedback Gracefully\n1. Don’t Take It Personally\nReviews critique code, not you.\n2. Ask Questions\nIf unclear: “Could you clarify ‘more robust error handling’?”\n3. Discuss, Don’t Argue\nExplain your reasoning respectfully if you disagree.\n4. Thank Reviewers\n“Thanks for catching that!” acknowledges their effort.",
    "crumbs": [
      "Pull Requests & Review"
    ]
  },
  {
    "objectID": "pages/010-resources.html",
    "href": "pages/010-resources.html",
    "title": "Workspace & Resources",
    "section": "",
    "text": "pytest\npytest is a mature, full-featured Python testing framework that makes it easy to write readable and maintainable tests.\nYou can install pytest with:\n\npipcondauv\n\n\n# Using pip (built-in with Python)\npip install pytest pytest-cov \n\n\n# Using conda (recommended for data science)\nconda install pytest pytest-cov\n\n\n# Using uv (fast, modern alternative)\nuv pip install pytest pytest-cov\n\n\n\n\n\nBlack\nBlack is Python code formatter that automatically reformats your code to follow PEP 8 style guidelines. Black will adjust spacing, line length, quotes, and more, eliminating debates about code style.\nBlack ensures uniform code style across all contributors, eliminating the need for manual formatting.\nInstall Black with:\n\npipcondauv\n\n\n# Using pip (built-in with Python)\npip install black\n\n\n# Using conda (recommended for data science)\nconda install black\n\n\n# Using uv (fast, modern alternative)\nuv pip install black\n\n\n\n\n\nCalculator library\nA demo repository with a simple Python calculator library with examples practicing GitHub workflows, with examples of automated testing and continuous integration.\nhttps://github.com/Bristol-Training/demo-calc-lib\ndemo-calc-lib/\n├── .github/\n│   └── workflows\n│       └── pytest.yml\n├── .gitignore\n├── calc_demo.py\n├── calc_lib.py\n├── README.md\n├── requirements.txt\n└── test_calc_lib.py\n\n\nStatistics library\nA demo repository with a simple statistics library for practicing team collaboration, automated testing, and continuous integration.\nhttps://github.com/Bristol-Training/demo-stats-lib\ndemo-stats-lib/\n├── data/\n│   ├── temp1995.csv\n│   └── temp2005.csv\n├── .gitignore\n├── README.md\n├── requirements.txt\n├── stats_lib.py\n├── stats_demo.py\n└── test_stats_lib.py",
    "crumbs": [
      "Workspace & Resources"
    ]
  },
  {
    "objectID": "pages/500-gh-testing.html",
    "href": "pages/500-gh-testing.html",
    "title": "Testing",
    "section": "",
    "text": "Why Testing Matters\nTesting is a critical part of software development that helps ensure your code works as expected and continues to work as you make changes. Well-tested code is:\n\nMore reliable: Catches bugs before they reach production\nEasier to refactor: You can confidently make changes knowing tests will catch regressions\nBetter documented: Tests serve as executable examples of how code should be used\nMore maintainable: Future developers (including future you) can understand intended behavior\n\n\n\nWhy Testing Matters in CI/CD\nIn modern software development, Continuous Integration and Continuous Deployment (CI/CD) pipelines automatically build, test, and deploy code. Testing is the critical safety net that makes this automation possible:\n\nAutomated Quality Gates: Tests run automatically on every change, preventing broken code from reaching production\nFast Feedback: Developers know within minutes if their changes break existing functionality\nConfidence in Deployment: Well-tested code can be deployed frequently and safely\nTeam Collaboration: Tests catch integration issues when multiple developers work on the same codebase\nDocumentation: Tests serve as living examples of how the code should behave\n\nWithout comprehensive testing, CI/CD becomes risky - you’re automating the deployment of potentially broken code.\n\n\nTypes of Tests\n\nUnit Tests\nTest individual functions or methods in isolation. They should be: - Fast to run - Independent of each other - Focused on a single piece of functionality\nExample:\ndef test_mean():\n    assert mean([1, 2, 3, 4, 5]) == 3.0\n    assert mean([10, 20]) == 15.0\n\n\nIntegration Tests\nTest how different components work together. They verify that modules interact correctly.\n\n\nTest-Driven Development (TDD)\nA development approach where you:\n\nWrite a failing test first\nWrite the minimum code to make it pass\nRefactor while keeping tests green\n\n\n\n\nTesting in Python with pytest\nPython’s pytest framework makes testing straightforward:\n# test_stats_lib_short.py\nimport pytest\nfrom stats_lib import mean, variance\n\ndef test_mean_basic():\n    \"\"\"Test mean with simple values\"\"\"\n    assert mean([1, 2, 3]) == 2.0\n\ndef test_mean_empty_list():\n    \"\"\"Test mean handles empty list appropriately\"\"\"\n    with pytest.raises(ValueError):\n        mean([])\n\ndef test_variance():\n    \"\"\"Test variance calculation\"\"\"\n    result = variance([1, 2, 3, 4, 5])\n    assert abs(result - 2.0) &lt; 0.01  # floating point comparison\nRun tests with:\npytest\npytest -v  # verbose output\npytest test_stats_lib  # specific file\nYou can also measure code coverage (i.e., see which parts of your code are exercised by your tests):\npytest --cov\n\n\nBest Practices\n\nTest edge cases: Empty inputs, negative numbers, very large values\nUse descriptive test names: test_mean_with_negative_numbers is better than test1\nOne assertion per test: Makes failures easier to diagnose\nKeep tests independent: Tests shouldn’t rely on execution order\nAim for good coverage: But 100% coverage doesn’t guarantee bug-free code\n\n\n\nFurther Information\nPractical PyTest. A practical introduction to testing, aimed at developers who are unsure about its value. It explains why testing matters, how it can improve confidence in your code, and hopefully makes a convincing case for adopting testing as part of your workflow.\nBest Practices in Software Engineering. An introduction to some techniques and processes which are essential if you are going to be developing professional-quality software: documentation, testing and licensing.",
    "crumbs": [
      "Testing"
    ]
  }
]